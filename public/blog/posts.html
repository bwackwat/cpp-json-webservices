<div id='posts'><div id='post'><div id='posttitle'>Testing Part 3</div><div id='postdate'>Wed Jun 24 2015 01:50:57 GMT-0400 (EDT)</div><br><div id='posttext'>I surrender to my desires of code coverage. I managed to get a code coverage tool working, but it simply was not worth my time maintaining. I realized, luckily, that I didn't need that many tests to cover all the critical and major coverage-branches of my code. I will put code coverage deep on the back burner and focus on actually writing some additional tests before any other feature additions.<br><br>In other news, the set of apps is now hosted on Debian 8.1! Very little difference from Ubuntu, but I appreciate the minimalism. I had also created a small amount of clutter on the other DigitalOcean droplet and this act helped <b>clean</b> it up. Debian has a node package which came before the introduction of NodeJS, so I had to alter my <b>deploy</b> strategy. And finally, I needed to backup and restore my MongoDB data using <b>mongodump and mongorestore</b>. Overall, there was some frustration with code coverage, yet relief with server restoration. Thanks DigitalOcean! For my domain name, I only had to change a single use case of the old server's IP address at Namecheap. After DNS propagation, a database restore, and a quick test, everything was running smoothly.<br>
<br>The list of TODO's is very manageable currently. I need time to work on other things and let this project settle. I'll make a few repairs across the next several days, and perhaps add a test or two. The blog will grow with a shift-in-perspective (and hopefully a shift-in-appearance). That's it for testing parts 1-3. Cheers.</div></div><hr><div id='post'><div id='posttitle'>Testing Part 2 - Lessons learned; a roadmap.</div><div id='postdate'>Mon Jun 22 2015 23:15:34 GMT-0400 (EDT)</div><br><div id='posttext'>Testing has been brutal, yet very valuable. Just by working on a few simple tests I've been forced to rework infrastructure pieces and reconsider some of my development strategies. I've created a load test for the public-facing HTML, CSS, and JS. I've also created a selenium test which creates an admin, logs in, logs out, creates a user, logs in, logs out, and then proceeds to my personal site and fills out the contact form. I will be able to quickly determine if those features have broken after a number of changes, they run quickly, and they cover a lot of code. I have investigated code coverage tools and I intend to make it a development build step in the future.<br>
<br>
The few tests I have made reveal plenty, and I am feeling the importance now of letting my dust settle and "gold-plating" some of the features of the site. Dust? Yeah, I started to use <a href='http://jshint.com/install/'>jslint</a> and there was lots of <i>lint</i>.<br>
<br>So uh, this first round of testing sucked because it punished me for my naivety. On the upside, as I progress down this path my code will be more reliable and stable. I'll need to write more tests, figure out test coverage, and continue to make my build/deploy story cleaner and friendlier. Cheers.</div></div><hr><div id='post'><div id='posttitle'>Testing Part 1 - At a Glance</div><div id='postdate'>Fri Jun 19 2015 03:17:14 GMT-0400 (EDT)</div><br><div id='posttext'>Testing is important because it prevents users of your software from finding bug and thus having a poor experience. <i>Clearly</i> testing should always be conducted and you must be crazy to dislike or resist it. But testing software is not necessarily having a complete set of supreme tests which covers every inch of code and considers every edge case. That would be unrealistic. The form of testing which we--critically critiquing engineers--do not always realize is bottom-up manual testing. This includes pressing keyboard buttons, waiting, or clicking around on the screen. It includes compiling or running your code and seeing if it works. Also, it means sitting and thinking about possible ways your recent code changes might break things.<br>
<br>
Just remember, your <b>must</b> be testing your code, all the time. Literally.<br>
<br>
Well what about unit, integration, smoke, black-grey-white-box, system, acceptance, performance, functional, usability, accessibility, regression, sanity, A/B, alpha, beta, security, and compatibility testing? TDD, BDD, agile, waterfall, lean, iterative, clean-room, or scum methodologies? The answer to what kind of empirical, automatic testing any engineer would really want to use and rely on, depends on the use cases and structure of his/her technology. Plenty of service architectures pair well with unit and integration test libraries. Algorithms may require smoke and performance tests. Web apps require usability and functional tests for positive user experiences. Deployment cycle duration, team size, and coordination requirements might make the difference between claiming to be defined by agile, waterfall, or TDD strategies. Figure out a scheme that best suits your needs, and test the software well.<br>
<br>
For this set of web apps there are two things that are immediately important for testing success. Page availability or performance, and the functional requirements of each app. Unit tests are not going to be worth my time because mocking JavaScript objects (in NodeJS or client-side) would be difficult and the number of measurable units is small. After recently refactoring big chunks of framework code such that most of the apps broke afterwards, it has become sharply apparent that a set of core tests would benefit my productivity.<br>
<br>
The next part of this topic will discuss results of testing this site. I think I'll check out some smoke, performance, and functional testing techniques. (I also really appreciate code coverage so that will happen too.)</div></div><hr><div id='post'><div id='posttitle'>WebSocket Framework Refactorization</div><div id='postdate'>Thu Jun 18 2015 12:13:19 GMT-0400 (EDT)</div><br><div id='posttext'>There is a line to be drawn for web services between using HTTP REST APIs or AJAX, and WebSockets. Currently this site's infrastructure is a static web server for basic usage and navigation, and a handful of NodeJS WebSocket servers for dynamic content. I use Secure WebSockets (wss://) so that I can verify authentication information server-side. In my experience, WebSockets may not be necessary, but they greatly simplify security and vertical scaling requirements for games and user-data-heavy apps.<br>
<br>
Another big step in the development of this site will be the addition of a REST API. This will be excellent for smaller services which don't require the full-duplex communication of WebSockets, and will rarely have static content which can be served from a file via the static file server.<br>
<br>
So, I'll find a line to draw. Some apps will utilize the API, other apps will utilize the WebSocket framework. Cheers.</div></div><hr><div id='post'><div id='posttitle'>いろは(Iroha), a Japanese poem, and a perfect panagram.</div><div id='postdate'>Wed Jun 17 2015 00:23:44 GMT-0400 (EDT)</div><br><div id='posttext'><table><tr><td style="padding-left: 20px;">
いろはにほへと<br>
ちりぬるを<br>
わかよたれそ<br>
つねならむ<br>
うゐのおくやま<br>
けふこえて<br>
あさきゆめみし<br>
ゑひもせす</td><td style="padding-left: 20px;">
Even the blossoming flowers<br>
Will eventually scatter<br>
Who in our world<br>
Is unchanging?<br>
The deep mountains of karma<br>
We cross them today<br>
And we shall not have superficial dreams<br>
Nor be deluded.<br></td></tr></table>
<a href="https://en.wikipedia.org/wiki/Iroha">Source</a>
<br>
Well, that was an enlightening thing for me. Also check out <a href="https://en.wikipedia.org/wiki/Pangram">panagrams</a>.</div></div><hr><div id='post'><div id='posttitle'>Old Java and the Next Step</div><div id='postdate'>Tue Jun 16 2015 12:27:10 GMT-0400 (EDT)</div><br><div id='posttext'>I have always kept a directory structure containing my old Java, Ruby, C, C#, C++, and other projects through high school and college (including coursework.) I stumbled upon it recently and decided it would be cool to host some of the more-complete, functional projects. The first project which I think is worth my time adding to the site is Asteroids! I replicated the classic Asteroids! game from 1979 Atari, which I played on Windows... somehow. It's pretty cool and uses some cryptic Java and Swing 2D graphics. I was really surprised to see my old coding style and how sharp it was. My variables were named with only a few characters! Soon both the code, a .JAR, and a .JNLP file will be available as a new app on the site. <i>Using Java Web Start and JNLP is like sculpting with boogers.</i> It is a good idea in principle, but just download the .JAR. Linux support for .JNLP is poor, getting a nicely signed certificate is annoying, and why not just use the .JAR anyways?<br>
<br>
I've reached a classic point in my development of the website. It is the feeling of creeping stagnation. I still have ideas and the TODO list grows, but my goals have mostly already been achieved. I need to keep blogging, working on new apps, and prettifying the existing apps. The "next step" of this whole project existing as a series of apps will result in some reorganization of my planning. My strategies for working on these apps will shift into something different and I cannot tell what it is yet.<br>
<br>
Maybe I just got a little demotivated. That's okay, it won't last long.</div></div><hr><div id='post'><div id='posttitle'>A Lesson In Production</div><div id='postdate'>Fri Jun 12 2015 15:38:14 GMT-0400 (EDT)</div><br><div id='posttext'>I told a few people to have a look at my personal website, finally. I was excited for them to be able to securely access my site and not see any broken things right?<br><br>
<i>Sure</i>, but upon adding a feature to the site and breaking a bunch of pages, there was an issue. I had to develop in another environment so that my "production" environment was stable. <b>Finally</b> I am feeling the necessity of this classic paradigm. I was no longer just playing around and building apps, I was the master of a service which was soon to be expected by others to be running smoothly. Not so quickly, however, was I able to move all the stuff which enabled my development to a "localhost" environment on a another machine. Below are the strenuous steps I took to get my development environment working.<ul><li>First I tried setting up everything on Windows 8. Nope. Stuff broke everywhere (node-gyp has a good number of dependencies.) Even worse, my bash scripts for configuring stuff were obsolete.</li>
<li>Admitted Linux is the thing I should use, (especially) if I am deploying to Linux.</li>
<li>Realized that FreeBSD is an awesome alternative to Ubuntu and decide to migrate my DigitalOcean droplet to FreeBSD in the future.</li>
<li>Okay. Now I need to get a FreeBSD machine running, port stuff that needs to be ported to it, and start developing again.</li>
<li><b>*Research*</b> Okay. Dual booting this is going to be annoying. Virtual machines! Installing VirtualBox immediately demolished my wacky Belkin N600 Wireless USB Network Adapter and I don't have internet.</li>
<li>Screw around for a while trying to get old, decrepit drivers to work on Windows 8.1 again, while also trying to keep VirtualBox installed.</li>
<li>Internet connection up, PC-BSD .OVA corrupt. Ugh. I torrent the PC-BSD .OVA and fire it up. Nice!</li>
<li>It is quickly apparent that: Linux virtual machines are awesome, and PC-BSD is barely different than every other consumer/desktop/window based distribution I have tried. That's okay, BSD is awesome so I'll roll with it for quite a while. Because UC Berkeley. Because BSD sockets.</li>
<li>Push to GitLab from DigitalOcean droplet. Pull from GitLab within PC-BSD VM and install dependencies.</li>
<li>A ton of stuff is broken immediately and I realize my naivety. What a <b>beautiful</b> learning experience. I have to solve a bunch of problems which relate the to differences between "prod" and "dev" environments. For example: I remove all my instances of "bwackwat.com" and replace them with a configurable host variable.</li>
<li>Now I can develop locally using localhost in this PC-BSD VM (which runs nicely on my Windows 8 build.)</li>
<li>Deploying requires a push to GitLab, a pull from GitLab on the server, and running my build script with a special keyword indicating the production environment.</li></ul>
<br>It was really an excellent experience, and now I can test new apps/features on my delicious little BSD VM and can expect redeployments on my server to be safe. This post was submitted in PC-BSD. It was a good lesson in production, and as I progress with my framework, everything will continue getting fine-tuned for the development environment and for production deployments. I hope this was at least a little enlightening. Cheers!</div></div><hr><div id='post'><div id='posttitle'>Abstraction or "Artificial Intelligence"? A Different Industry.</div><div id='postdate'>Tue Jun 09 2015 23:21:56 GMT-0400 (EDT)</div><br><div id='posttext'>If you hop over to the Wikipedia page for "Applications of Artificial Intelligence" you'll find the text: "...all of the following were originally developed in AI laboratories: time sharing, interactive interpreters, graphical user interfaces and the computer mouse, rapid development environments, the linked list data structure, automatic storage management, symbolic programming, functional programming, dynamic programming and object-oriented programming." Even OOP was developed in an "AI" laboratory? This is not the modern, novel conception.<br>
<br>
Rather, I propose that artificial intelligence has simply provided <i>very effective</i> abstractions which work well for us. The computer mouse? Well sure, once you've made the truly proper analysis of the necessities of a human-computer interface, the mouse becomes obvious. Nonetheless, it is an abstraction from the keyboard, a GUI, your hand, and the pixels of a screen. OOP was a result of AI which had the proper analyses of a way to explain the real world in a programming language. (Hence the common polymorphism: my Truck and Van objects are both Car objects, but a Van object is never a Truck object.)<br>
<br>
The C language is a remarkably standard abstraction over assembly, which is itself a standardized abstraction over the commodity hardware of this decade. (Thanks Intel!) However, the number of abstractions over C and the JVM are uncountable. (At least we have BSD sockets.) The future of the software industry will result in abstractions which are the result of proper analyses of the next human usability requirements. With the right programming language in a decade from now, you'll be able to do much more with fewer lines of code using well-thought-out, standardized abstractions. Just as a few LOC is NodeJS (utilizing the standards of JavaScript and C++,) can create a web server in far fewer lines than a web server in C.<br>
<br>
<b>SHOUTOUT TO MESOSPHERE, DOCKER, KUBERNETES, AND APACHE SPARK:</b> Be careful fellas because you're challenge is to develop a seriously valuable abstraction and whoever comes out alive will be accommodating the next fortune 500 company's datacenters. By the business startup necessity of creating data, datacenters shall be easily programmable.</div></div><hr><div id='post'><div id='posttitle'>Security, Reliability, Robustness, and Simplicity</div><div id='postdate'>Sat Jun 06 2015 00:02:19 GMT-0400 (EDT)</div><br><div id='posttext'>If you're an extreme hacker or the NSA, chances are you have the capacity to destroy my server.<br>
<br>
If you're a developer, friend, or anyone else, you <i>might</i> be able to hack my servers. Try me. (Seriously, try some XSS hacks and contact me if you succeed.)<br>
<br>
Nonetheless, I've been putting some time into research and without completely ruining my special security secrets I'll name a few topics.
<ul><li>iptables</li>
<li>ip6tables</li>
<li>HTTPS</li>
<li>SecureWebSockets</li>
<li>SSH private key authentication</li>
<li>Input sanitization</li>
<li>Ports open only on non-root processes</li>
<li>Logging</li></ul><br>
I am feeling pretty good about this and I'm going to give the whole topic a rest.<br>
<br>
The site is unreliable only because there is little to zero traffic, and I don't always have it running because of WIPs. Otherwise, my impressions are such that NodeJS and my architecture can maintain some nice, robust services. It will be critical for me as I move forward, to maintain simplicity. I have just recently merged build files, refactored code into a utility file, and logically reorganized the site's directory structure. Everything feels very good. I think there is more refactoring to be done, but there are yet to be any bloated files. Many people file complaints about NodeJS's tendency for "callback hell" but I'm fairly convinced that, at least some of these people have simply done a poor job refactoring and organizing their code. I see well-refactored code as a key to large, complex, yet robust software applications. The case for NodeJS is no different, except that it takes longer to get to a stage where refactoring is necessary. This site is a construction of apps with shared infrastructure principles. The more apps and features to existing apps that are added, gives me the challenge as an engineer to wisely refactor.<br><br>The TODO list is big. I knocked a few items off the list this week. A few out of many dozens. Cheers.</div></div><hr><div id='post'><div id='posttitle'>Addicted To Performance + More Features</div><div id='postdate'>Thu Jun 04 2015 01:23:48 GMT-0400 (EDT)</div><br><div id='posttext'>Apparently a common coding practice of mine, which comes with appreciation of simplicity and minimalism, is to seek out the most performant practices of my select technology stack. I have recently been doing tons of research between different web frameworks and languages. First of all:<br><br>
<h3>C is <b>beautiful!</b></h3><br><br>
I don't think I can stress it enough. I've done a few things in C and although it is clearly the choice for embedded systems, I find that it isn't very readable, manageable, or high level (obviously). Many of the fastest most efficient infrastructures in the industry today are written in C++. With C++, engineers can design high level libraries for others. Although the code is still not as readable as Java, for instance, you get excellent control over the memory model. There is one player we must not forget however:<br><br>
<h3>Java is <b>compiled to bytecode!</b></h3><br><br>
Bytecode is a hype terminology. It refers to classic code generation; code generated to run on the Java Virtual Machine. It can also be very performant. The best part is that you can read your code! Most benchmarks reveal that C/C++ is still measurably faster.<br><br>
NodeJS has served me well for one awesome reason: productivity. Benchmarks reveal it's performance is not really even close to web/websocket servers written in C/C++/Java, but I realize that it is tailored precisely for the web. This is <b><i>excellent</i></b>. Not only that, but I get to use the same language on the front-end as well. I get to take a lot of lazy-advantage of JavaScript Objects and JSON. It's great. My services are rarely including other packages, because a majority of the critical language functionality already exists! Using JavaScript and NodeJS, I am gratefully accepting less performance (comparatively), for productivity. I can reuse code, but I don't need to fuss with file-fattening object-oriented language syntax. *cough* It won't be fun to secure every single loose bolt on these NodeJS servers... many things are breakable, I'd bet!<br><br>
Anyways, toady I carefully added a bunch of content to my personnel site. I also added a contact form which mails my Gmail account, awesome!</div></div><hr><div id='post'><div id='posttitle'>Feature Addition - Surprisingly Manageable</div><div id='postdate'>Wed Jun 03 2015 01:01:01 GMT-0400 (EDT)</div><br><div id='posttext'>Just recently finished adding two solid features to the CMS. Yesterday I added functionality to edit posts, and today I created a simple Q&A captcha system. Each took only a few hours. The architecture I have used for NodeJS and the WebSocket connection is nicely extensible, and the kindness of the framework shows!<b>Stoked.</b><br><br><h3>GitLab</h3>Most of the code for this site is publicly available on <a href="https://github.com/bwackwat/">GitHub</a>, but I decided that it has become a little to valuable for the whole world. I am proud of my work and maybe it will really get me somewhere, quickly, soon. Maybe I'll change my mind. Maybe not. For now, the project is steadily progressing in stability and in features. Soon to come: more fun apps! Cheers.</div></div><hr><div id='post'><div id='posttitle'>Lets See If I Can Edit Posts From My Custom CMS</div><div id='postdate'>Tue Jun 02 2015 00:59:38 GMT-0400 (EDT)</div><br><div id='posttext'>It appears my custom CMS works!<br>
<br>
~<br>
<br>
I am having an awesome time using my secure website to handle things. I laugh at thinking that users can see all the admin capabilities just from the client-side JavaScript, but only the server can tell which socket connection represents that of the admin's...<br>
<br>
If anyone wants to inform me of security vulnerabilities... that would be great! Please do so kindly.</div></div><hr><div id='post'><div id='posttitle'>Feeling Legitimate</div><div id='postdate'>Mon Jun 01 2015 01:19:44 GMT-0400 (EDT)</div><br><div id='posttext'>The whole site is now configured for SSL through some awesome, free SSL certs from StartCom (StartSSL). I had an excellent time learning how to use openssl, all about certificate chaining, and the security features of modern TLS. I can now blog safely, and add forms of content creation for users to feel good about.<br>
<br>
I am feeling like this is a legitimate web site. I will continue to update my portfolio page, make blog posts, and think about some cool apps that people would like. Everything will progressively upgrade. I am also considering some webserver alternatives like ulib. Check out <a href="https://www.techempower.com/benchmarks/">TechEmpower</a> for some <i>really</i> impressive webserver benchmarks. My plan is to build out the site more, and eventually create a functionally similar backend using ulib or another performance-oriented solution. Then, I can run my own benchmarks. Who knows, maybe I'll find that NodeJS WebSocket implementations are fast enough and I wont need to actually shift architectures. That would be cool.<br>
<br>
<b>Lets Talk Gamification</b><br>
<br>
I think gamification is awesome. It is a clear way to excite users and make them want to come back for more. Maybe I have simply enjoyed too many video games in my life. Nonetheless, I hope to come up with some apps/products where users can actually "build" a certain identity and maintain a small to large desire to come back to the site. Currently, there isn't really any reason at all for anyone to come to the site. I'll say that maybe my apps have interesting source code, you might want to check out the climbing log, or read some blog posts; but this thing is NOT gamified yet. Let's get addicted.</div></div><hr><div id='post'><div id='posttitle'>I Should Wear Shades, Simple Code</div><div id='postdate'>Thu May 28 2015 20:22:02 GMT-0400 (EDT)</div><br><div id='posttext'>I should wear shades not only because the future of tech is so bright, but because blue-eyed peoples are sensitive to the sun's rays.<br>
<br>
Anyways... I would like to reiterate the previous post and state that the developers of the future will not need to work so hard when it comes to deploying massively scalable and truly reliable applications. But be weary, for every new, unstandardized technology comes a lot of <b>junk</b> and it is critical we remember the importance of <b><i>simple, clear-cut architecture solutions</i></b>. For instance, NodeJS has made web application development very quick for me, and I like it for this reason alone. However there were far too many snippets and examples online where developers crowded their JS files with unnecessary requires or recreated the wheel. NPM is filled with trash--practically to the brim--such that you need to check the last commits on GitHub, read through source, and compare packages in order to verify it. In general the industry is filled with hype, and I intend to stick to the grits of what's true in our connected world. That includes: BSD sockets, pure JavaScript, HTML, and CSS for the web, a reliable key-value store like etcd for distributed systems, and simple coding practices. Why use DOCTYPE again? Why use Coffeescript again? Why even containerize something which has automatic restarts built-in and a carefully organized set of tasks (such that resources are controlled)? Why use nothing but JSON in REST API's? Why use several layers of functions, methods, and variables with confusing terminology just to wrap a POSIX socket?<br>
<br>
Just remember, the more lines of code you think you need (from bits in the cache and up), the slower your thingy is gonna get.</div></div><hr><div id='post'><div id='posttitle'>DevOps for Software Developers, not Computer Engineers</div><div id='postdate'>Tue May 26 2015 21:15:19 GMT-0400 (EDT)</div><br><div id='posttext'>I am enjoying a ride on a great wave into the age of cloud computing, where old hardware + software legacy infrastructure is looking utterly decrepit, and where solutions like Docker, Kubernetes, Apache Mesos, Rocket, and Azure are the young and spicy choices for the next generation of DevOps.<br><br>Take a breather.<br><br>The point of this post is that software developers in the next generation will not be confused and will not need to meddle with a layer of messy "hardware infrastructure." I think Apache Mesos sums it up nicely:<blockquote cite="http://mesos.apache.org/">Program against your datacenter like it’s a single pool of resources.</blockquote>This implies that developers within a startup of the next generation can deal with a single endpoint (server address, hosted on the strength of a cluster of machines), which can reliably handle incoming requests from all the company's users.<br><br>As an engineer I see this as a chance to add additional low-level programming language features which handle these additional resources. A system which organizes a cluster of machines will be built into a languages' framework such that, code handling an incoming request, will automatically send it to the proper machine (load balancing) on the cluster which has the proper available resource (process, disk space, CPU, etc...).<br><br>The architecture which hosts this blog as an "app", is prepared for this new wave. For each app a new NodeJS process is spawned. This is forward-looking in the sense that, load balancing is intuitive (spawn the process somewhere else). However, I do not think that the current set of options are completely realized. Docker has an odd set of terminology which fits their architecture nicely but not really my mind. Apache Mesos appears promising with a nice master/slave machine configuration scheme, but I'm not sold. I'm looking for some high-quality NodeJS packages which handle cluster management at a low level so that I can find out where my MongoDB server is at run-time and give my other apps the right address.<br><br>I'm skeptical as to how much I actually know about the topic, so that is all for now. The point is yet still, that these first-generation cluster computing solutions are not seamless. I see NodeJS as a way to seamlessly serve requests of all kinds, handle app spawning, and do other computation. I do not yet see Docker or Kubernetes as seamless integration. I think for a long while I will be manually configuring and balancing a small set of NodeJS-optimized servers. Cheers to simplicity.</div></div><hr><div id='post'><div id='posttitle'>Developing with NodeJS</div><div id='postdate'>Tue May 26 2015 02:15:30 GMT-0400 (EDT)</div><br><div id='posttext'>I've had a great time working on the series of apps located at bwackwat.com. I plan to sharpen the sites and work on some nice NodeJS-based "app" infrastructure. In the future I will consider using Docker for scalability purposes. In addition, although MongoDB integrates nicely with both JavaScript objects and my brain's organization, I am interested in entertaining the idea of using Redis, or an ACID compatible database.<br>
<br>
As for NodeJS: JavaScript is awesome to use for front and back end work, the community of coders and support for libraries is good if not great, and I am enjoying it's ease of deployment. I hope it can scale. MongoDB is great for general document storage.<br>
<br>
I am really looking forward to having more fun with WebSockets.</div></div><hr></div>